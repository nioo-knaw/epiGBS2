#prepares the genome for bismark
rule genome_prep_for_bismark_reference_bismark:
    input:
        reference=expand("{path}/{genome}", path=config["ref_dir"],genome=config["genome"])
    output:
        preparedReference=expand("{path}/Bisulfite_Genome/CT_conversion/genome_mfa.CT_conversion.fa",path=config["ref_dir"])
    params:
        refDir=expand("{path}/",path=config["ref_dir"])
    conda:
        "../env/bismark.yaml"
    shell:
         '''
         bismark_genome_preparation {params.refDir}
         '''

#Align the trimmed reads to the reference clusters
# --un outputs  unmapped reads to the output directory #Needed?
# --ambigious outputs ambigious writes the ambigiuos reads #Needed?
# --non_directional: sequencing library not in a specific direction
# --rg_tag --rg_id adds sample names to the bam file is necesarry for bisSNP snp calling

rule alignment_reference_bismark:
    input:
        R1merged=expand("{out}/cutadapt/{{sample}}_trimmed_filt_merged.1.fq.gz",out=config["output_dir"]),
        R2merged=expand("{out}/cutadapt/{{sample}}_trimmed_filt_merged.2.fq.gz",out=config["output_dir"]),
        preparedReference=expand("{path}/Bisulfite_Genome/CT_conversion/genome_mfa.CT_conversion.fa",path=config["ref_dir"])
    output:
        alignment=expand("{out}/alignment/{{sample}}_trimmed_filt_merged.1_bismark_bt2_pe.bam",out=config["output_dir"])
    params:
        out=expand("{path}",path=config["output_dir"]),
        sample="{{sample}}",
        refDir=expand("{path}/",path=config["ref_dir"])
    conda:
        "../env/bismark.yaml"
    threads: 8
    shell:
        "bismark --un --ambiguous --genome {params.refDir} --non_directional -1 {input.R1merged} -2 {input.R2merged} -o {params.out}/alignment/ --rg_tag --rg_id {params.sample}"


# Call methylation sites with bismark
# -p paired end reads
# --CX output all C's independent of context (if not present only CG sites)
# --no_overlap scores overlapping methylation sites only using Read 1.
# --report Prints out a short methylation summary as well as the parameters used to run this script. 
# --bedGraph outputs a bedGraph file 
# --cytosine_report produces a genome-wide methylation report for all cytosines in the genome. (Not sure how this interacts with bedGraph)
# 
rule methylation_calling_reference_bismark:
    input:
        alignment=expand("{out}/alignment/{{sample}}_trimmed_filt_merged.1_bismark_bt2_pe.bam",out=config["output_dir"]),
        refNN=expand("{path}/{genome}", path=config["ref_dir"],genome=config["genome"]),
        preparedReference=expand("{path}/Bisulfite_Genome/CT_conversion/genome_mfa.CT_conversion.fa",path=config["ref_dir"])
    output:
        calling=temp(expand("{out}/methylation_calling/{{sample}}_trimmed_filt_merged.1_bismark_bt2_pe.CX_report.txt",out=config["output_dir"])),
        coveragecompr=expand("{out}/methylation_calling/{{sample}}_trimmed_filt_merged.1_bismark_bt2_pe.bismark.cov.gz",out=config["output_dir"])
    params:
        out=expand("{path}",path=config["output_dir"]),
        refDir=expand("{path}/",path=config["ref_dir"])
    conda:
        "../env/bismark.yaml"
    threads: 2
    shell:
        "bismark_methylation_extractor -p --CX --no_overlap --report --bedGraph --cytosine_report --genome_folder {params.refDir} {input.alignment} -o {params.out}/methylation_calling/"

rule gunzip:
    input: 
        calling=expand("{out}/methylation_calling/{{sample}}_trimmed_filt_merged.1_bismark_bt2_pe.CX_report.txt",out=config["output_dir"])
    output:
        coverageuncompr=expand("{out}/methylation_calling/{{sample}}_bismark_bt2_pe.CX_report.txt.gz",out=config["output_dir"])
    threads: 1
    shell:
        "gzip -c {input.calling} > {output.coverageuncompr}"

##SNP_calling

genomePlaceHolder = config["genome"].split(".")[0]
#Sort the bam files for SNP calling. (Do we put this or the non sorted in the output directory?)
rule sort_bam:
    input:
        alignment=expand("{out}/alignment/{{sample}}_trimmed_filt_merged.1_bismark_bt2_pe.bam",out=config["output_dir"]),
    output:
        alignmentSorted=temp(expand("{out}/alignment/{{sample}}_sorted.bam",out=config["tmpdir"]))
    conda:
        "../env/samtools.yaml"
    shell:
        "samtools sort {input.alignment} > {output.alignmentSorted}"
#Index the sorted bam files
rule index_bam:
    input:
        alignmentSorted=expand("{out}/alignment/{{sample}}_sorted.bam",out=config["tmpdir"])
    output:
        aligmentIndex=temp(expand("{out}/alignment/{{sample}}_sorted.bam.bai",out=config["tmpdir"]))
    conda:
        "../env/samtools.yaml"
    shell:
        "samtools index {input.alignmentSorted}"
#CreateSequenceDirectory does not allow for NNNN's to be present in the genome thus they need to be replaced        
#Create the reference dictionary
rule referenceDict:
    input:
        AsReference=expand("{path}/{genome}",path=config["ref_dir"],genome=config["genome"])
    output:
        AsReferenceDict=expand("{path}/{genome}.dict",path=config["ref_dir"],genome=genomePlaceHolder)
    conda:
        "../env/picard.yaml"
    shell: 
        "picard CreateSequenceDictionary R={input.AsReference} O={output.AsReferenceDict}"

#Index the reference with NNNNs. If we don't this it skips the last line due to there not being an \n
rule faidx_ref:
    input:
        reference=expand("{path}/{genome}",path=config["ref_dir"],genome=config["genome"])
    output:
        referenceFai=expand("{path}/{genome}.fai",path=config["ref_dir"],genome=config["genome"])
    conda:
        "../env/samtools.yaml"
    shell:
        """
        samtools faidx {input.reference}
        """
#Bis snps needs a file of known snps to calibrate, which ensures that there it creates proper output and improves prescision. However,
#Since our pipeline is mostly denovo focused, we do not have known SNPS (#TODO allow knownSNPs in config). We can however trick bis-snp
#in to improving the output by inputting an empty V4.1 vcf file which has all the contigs in the header. (We don't know why this works)


rule vcfHeader:
    input:
        alignment=expand("{out}/alignment/{sample}_sorted.bam",out=config["tmpdir"],sample=SAMPLES[0]),
        aligmentIndex=expand("{out}/alignment/{sample}_sorted.bam.bai",out=config["tmpdir"],sample=SAMPLES[0]),
        reference=expand("{path}/{genome}",path=config["ref_dir"],genome=config["genome"]),
        AsReferenceDict=expand("{path}/{genome}.dict",path=config["ref_dir"],genome=genomePlaceHolder),
        referenceFai=expand("{path}/{genome}.fai",path=config["ref_dir"],genome=config["genome"])
    output:
        knownSNPs=temp(expand("{out}/alignment/knownsnps.vcf",out=config["tmpdir"]))
    conda:
        "src/env/bcftools.yaml"
    shell:
        """
        bcftools mpileup {input.alignment} \
        --fasta-ref {input.reference} -r 1 | \
        grep "#" | sed "s/4.2/4.1/" | grep -v "##FORMAT" | grep -v "##INFO" > {output.knownSNPs}
        """

rule countCovariates:
    input:
        alignment=expand("{out}/alignment/{{sample}}_sorted.bam",out=config["tmpdir"]),
        aligmentIndex=expand("{out}/alignment/{{sample}}_sorted.bam.bai",out=config["tmpdir"]),
        reference=expand("{path}/{genome}",path=config["ref_dir"],genome=config["genome"]),
        AsReferenceDict=expand("{path}/{genome}.dict",path=config["ref_dir"],genome=genomePlaceHolder),
        referenceFai=expand("{path}/{genome}.fai",path=config["ref_dir"],genome=config["genome"]),
        knownSNPs=expand("{out}/alignment/knownsnps.vcf",out=config["tmpdir"])
    output:
        recalc=temp(expand("{out}/alignment/{{sample}}_recalc_before.csv",out=config["tmpdir"]))
    conda:
        "src/env/env_bis-snp0.82.yaml"
    shell:
        """
        bis-snp -R {input.reference} \
        -I {input.alignment} \
        -T BisulfiteCountCovariates -knownSites {input.knownSNPs} \
        -cov ReadGroupCovariate \
        -cov QualityScoreCovariate \
        -cov CycleCovariate\
        -recalFile {output.recalc} \
        -nt 1 
        """
rule recalc:
    input:
        alignment=expand("{out}/alignment/{{sample}}_sorted.bam",out=config["tmpdir"]),
        aligmentIndex=expand("{out}/alignment/{{sample}}_sorted.bam.bai",out=config["tmpdir"]),
        reference=expand("{path}/{genome}",path=config["ref_dir"],genome=config["genome"]),
        AsReferenceDict=expand("{path}/{genome}.dict",path=config["ref_dir"],genome=genomePlaceHolder),
        referenceFai=expand("{path}/{genome}.fai",path=config["ref_dir"],genome=config["genome"]),
        knownSNPs=expand("{out}/alignment/knownsnps.vcf",out=config["tmpdir"]),
        recalc=expand("{out}/alignment/{{sample}}_recalc_before.csv",out=config["tmpdir"])
    output:
        recalcedBam=temp(expand("{out}/alignment/{{sample}}_recalc.bam",out=config["tmpdir"]))
    conda:
        "src/env/env_bis-snp0.82.yaml"
    shell:
        """
        bis-snp -R {input.reference}   \
        -I {input.alignment} \
        -o {output.recalcedBam} \
        -T BisulfiteTableRecalibration \
        -recalFile {input.recalc} \
        -maxQ 40 
        """
rule indexRecalc:
    input:
        recalcedBam=expand("{out}/alignment/{{sample}}_recalc.bam",out=config["tmpdir"])
    output:
        recalcedBai=temp(expand("{out}/alignment/{{sample}}_recalc.bam.bai",out=config["tmpdir"]))
    conda:
        "src/env/samtools.yaml"
    shell:
        "samtools index {input.recalcedBam}"


stand_call_conf=config["param_SNPcalling"]["stand_call_conf"]


def getStand_call_conf(stand_call_conf):
    if stand_call_conf == "default" or stand_call_conf == "":
        print(param_mq)
        mq = 20
    else:
        mq = stand_call_conf
    return mq


# call SNPs from recalibrated alignments
# -XX:ActiveProcessorCount=1  <- ensures not all cores are being used (although still uses more cores then necessarysrc.)
# -out_modes EMIT_ALL_CONFIDENT_SITES (Work in progress (default only outputs SNP sites so when combining you do not find coverage on homozygous ref alleles))

# -stand_call_conf defines the likelihood ratio criteria between best and second best genotype for call to be considered confident
# #TODO Default value is 20 for high depth of coverage. For multiple samples with low coverage (more than 100 samples with 4X coverage), the
# threshold could be defined lower than 10, or even 4. For ultra-high coverage sequencing, such as
# 50X, you could specify higher threshold to obtain higher accuracy. (So maybe play with this value?)

# -toCoverage 1000 maximum read coverage 
# -toCoverage 1000 maximum read coverage allowed
#-mmq 20 minimal mapping quality
#-mbq 20 minimal base quality
#-nt 1 "Number of threads" actually number of gatk instances started.
rule call_SNPs_reference:
    input:
        alignment=expand("{out}/alignment/{{sample}}_recalc.bam",out=config["tmpdir"]),
        recalcedBai=expand("{out}/alignment/{{sample}}_recalc.bam.bai",out=config["tmpdir"]),
        reference=expand("{path}/{genome}",path=config["ref_dir"],genome=config["genome"]),
        AsReferenceDict=expand("{path}/{genome}.dict",path=config["ref_dir"],genome=genomePlaceHolder),
        referenceFai=expand("{path}/{genome}.fai",path=config["ref_dir"],genome=config["genome"])
    output:
        perIndVCF=temp(expand("{path}/snp_calling/{{sample}}_snp.raw.vcf.out",path=config["tmpdir"])),
        perIndMethStats=temp(expand("{path}/snp_calling/{{sample}}_snp.raw.vcf.out.MethySummarizeList.txt",path=config["tmpdir"]))
    params:
        stand_call_conf=getStand_call_conf(stand_call_conf)
    log:
        expand("{path}/log/snp_call/{{sample}}_call.log",path=config["output_dir"])
    conda:
        "src/env/bisSNP.yaml"
    threads: 6
    shell:
        "(bis-snp -XX:ActiveProcessorCount=1 -T BisulfiteGenotyper -R {input.reference} -I {input.alignment} -vfn1 {output.perIndVCF} -out_modes EMIT_ALL_CONFIDENT_SITES -stand_call_conf {params.stand_call_conf} -toCoverage 1000 -mmq 20 -mbq 20 -nt 1) 2> {log}"

#Combines all different output files
#Order / zip vcf files
#bcftools annotate -x FORMAT/GP Removes a field which causes issues when merging
rule zip_vcfs_reference:
    input:
        perIndVCF=expand("{path}/snp_calling/{{sample}}_snp.raw.vcf.out",path=config["tmpdir"])
    output:
        perIndvcfGZ=expand("{path}/snp_calling/{{sample}}.vcf.gz",path=config["output_dir"])
    params:
        sample="{sample}"
    conda:
        "src/env/bcftools.yaml"
    shell:
        "bcftools view {input.perIndVCF}| sed 's/SAMPLE/{params.sample}/' | bcftools sort | bcftools annotate -x FORMAT/GP | bgzip -c > {output.perIndvcfGZ}"
#index them so we can use bcftools merge
rule index_vcfs_reference:
    input:
        perIndvcfGZ=expand("{path}/snp_calling/{{sample}}.vcf.gz",path=config["output_dir"])
    output:
        perIndVCFTBI=expand("{path}/snp_calling/{{sample}}.vcf.gz.csi",path=config["output_dir"])
    conda:
        "src/env/bcftools.yaml"
    shell:
        "bcftools index {input.perIndvcfGZ}"

#Merges the individual vcf files
# bcftools view -i 'GT[*]="alt"&&REF!="N"'. Filters site which do not have an alt allele in any individual + sites for which the ref = N
rule merge_vcfs_reference:
    input:
        perIndVCFTBI=expand("{path}/snp_calling/{sample}.vcf.gz.csi",path=config["output_dir"],sample=SAMPLES),
        perIndvcfGZ=expand("{path}/snp_calling/{sample}.vcf.gz",path=config["output_dir"],sample=SAMPLES)
    output:
        finalVCF=expand("{path}/snp_calling/snp.vcf.gz",path=config["output_dir"])
    params:
        outDir=expand("{path}/snp_calling/",path=config["output_dir"])
    conda:
        "src/env/bcftools.yaml"
    shell:
        """bcftools merge {params.outDir}/*.gz | bcftools view -i 'GT[*]="alt"&&REF!="N"' |  bgzip -c > {output.finalVCF}"""
